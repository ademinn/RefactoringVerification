\chapter{Описание предлагаемого подхода}

По определению, при проведении рефакторинга поведение программы не должно изменяться.
Поэтому, прежде чем описать алгоритмы верификации рефакторингов, требуется формализовать понятие <<одинаковое поведение>>.
Для этого введем понятие эквивалентности по редукции.
\begin{definition}
Выражения $\Gamma \vdash e_1$ и $\Gamma \vdash e_2$ назовем эквивалентными по редукции,
если для любых значений переменных из $\Gamma$ либо существует выражение $e'$ такое, что $e_1 \rightarrow^* e'$ и $e_2 \rightarrow^* e'$,
либо ни $e_1$ ни $e_2$ не могут быть редуцированы до нормальной формы.
Эквивалентные по редукции выражения будем обозначать $e_1 \equiv_r e_2$.
\end{definition}

\section{Выделение метода}

По определению, при выделении метода фрагмент кода, который можно сгруппировать, преобразуется в метод.
Выделенный метод должен находиться в том же классе, где первоначально находился выделенный фрагмент.
Если выделенный метод должен находиться в другом классе, то далее следует воспользоваться
другим методом рефакторинга -- перемещением метода.

Для начала определим внутреннюю редукцию по методу,
которая представляет собой подстановку тела метода при его вызове в другом методе,
определенном в том же классе или одном из его потомков.
\begin{definition}
Пусть в классе $C$ определен метод $m$, $mbody(m, C) = \overline{x}.e_m$.
Отношением редукции по методу $m$ назовем отношение со следующими правилами:
\begin{enumerate}
    \item $\cfrac{\Gamma \vdash this : D \qquad D <: C \qquad \overline{e} \rightarrow_m \overline{e}'}{this.m(\overline{e}) \rightarrow_m [\overline{e}'/\overline{x}]e_m}$
    \item $\cfrac{e \rightarrow_m e'}{e.f \rightarrow_m e'.f}$
    \item $\cfrac{e \rightarrow_m e' \qquad \overline{e} \rightarrow_m \overline{e}'}{e.m'(\overline{e}) \rightarrow_m e'.m'(\overline{e}')}$
    \item $\cfrac{\overline{e} \rightarrow_m \overline{e}'}{new\ C(\overline{e}) \rightarrow_m new\ C(\overline{e}')}$
    \item $\cfrac{e \rightarrow_m e'}{(D)e \rightarrow_m (D)e'}$
\end{enumerate}
\end{definition}
Заметим, что подстановка будет происходить, только если редукция проводится для тела одного из методов класса $C$ или его потомков.
В противном случае, для выражения $e$ существует только одно выражение, с которым оно состоит в отношении редукции по методу $m$ -- само выражение $e$.

При помощи редукции по методу введем понятие внутренней подстановки, которое необходимо для доказательства корректности алгоритма верификации выделения метода.
\begin{definition}
Пусть в классе $C$ определены методы $m$ и $m_0$, $mbody(m_0, C) = \overline{x}.e_0$.
Пусть после внесения изменений метод $m_0$ преобразовался в метод $m_0'$, $mbody(m_0', C) = \overline{x}.e_0'$, причем $e_0 \rightarrow_m e_0'$.
Такое преобразование будем называть внутренней подстановкой и обозначать $m_0' = inner_m(m_0)$.
\end{definition}

При выделении метода и при его верификации следует учесть следующие детали:
\begin{itemize}
    \item тело выделенного метода не может содержать прямой рекурсии -- до проведения рефакторинга выделяемый метод еще не существовал, а значит выделенный фрагмент не мог содержать его вызовов;
    \item в родительских классах не должен быть определен метод с тем же именем -- в противном случае изменится поведение класса, в котором производится выделение метода;
    \item в дочерних классах не должен быть определен метод с тем же именем -- в противном случае в дочерних классах изменится поведение методов, в которых используется выделяемый метод.
\end{itemize}

\begin{theorem}
Пусть в классе $C$ определены методы $m$ и $m_0$ и метод $m$ не содержит прямой рекурсии. Пусть $m_0' = inner_m(m_0)$.
Тогда, $\forall e : C, \overline{e}$ верно: $e.m_0(\overline{e}) \equiv_r e.m_0'(\overline{e})$.
\end{theorem}
\begin{proof}
Пусть $e$ не может быть редуцирован к виду $new\ C(\overline{e}')$. Тогда не могут быть редуцированы вызовы методов $m_0$ и $m_0'$, а значит оба выражения не могут быть редуцированы до нормальной формы.

Пусть $e$ может быть редуцирован к виду $new\ C(\overline{e}')$.

Проведем редукцию вызова метода $m_0$ по второму правилу редукции, затем в полученном выражении проведем редукцию всех вызовов методов $m$ тоже по второму правилу
(это можно сделать, так как на предыдущем шаге была произведена подстановка выражения $new\ C(\overline{e}')$ вместо переменной $this$). Полученное выражение обозначим $e_0$.

Проведем редукцию вызова метода $m_0'$ по второму правилу редукции, обозначим полученное выражение $e_0'$.

Из определения редукции по методу следует, что выражения $e_0$ и $e_0'$ равны.
В самом деле, процесс их вывода отличается лишь порядком проведения подстановок -- для $m_0$ сначала вместо $this$ было подставлено $new\ C(\overline{e}')$, а затем раскрыт вызов метода $m$;
для $m_0'$ сначала был раскрыт вызов метода $m$ (из определения внутренней подстановки), а затем вместо $this$ было подставлено $new\ C(\overline{e}')$.

Значит $e.m_0(\overline{e}) \equiv_r e.m_0'(\overline{e})$.
\end{proof}
\section{Замена условного оператора полиморфизмом}